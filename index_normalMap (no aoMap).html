<html>
	<head>
		<title>2nd Project - Vulcano</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}

		/*#text{
			width: 40%;
			position: absolute;
			left: 30%;
			top: 10%;
			text-align: center;
		}

		#text p{
			color: #e3e3e3;
			font-family: 'Antic', sans-serif;
		}*/
	
		</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OBJLoader.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<!--<link href="https://fonts.googleapis.com/css?family=Antic&display=swap" rel="stylesheet">-->

        <script type="text/x-glsl" id="vertex">
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;
	
			void main() {
				vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
				vPosition = vPos.xyz;
				vNormal = normalMatrix * normal;
				uVv = uv;
				gl_Position = projectionMatrix * vPos;
			}
			</script>
	
			<script type="text/x-glsl" id="fragment">
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;
			uniform vec3 pointLightPosition; // in world space

			uniform vec3 clight;
			uniform vec3 cspec;
			uniform vec3 cdiff;
			uniform float roughness;

			uniform sampler2D normalMap;
			uniform vec2 normalScale;
			const float PI = 3.14159;

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}

			#extension GL_OES_standard_derivatives : enable
	
			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
	
				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( uVv.st );
				vec2 st1 = dFdy( uVv.st );
	
				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;
	
				vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );
	
			}
	
			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				vec3 v = normalize( -vPosition);
				vec3 h = normalize( v + l);
				// small quantity to prevent divisions by 0
				float nDotl = max(dot( n, l ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);
				float nDotv = max(dot( n, v ),0.000001);
				vec3 fresnel = FSchlick(lDoth);
				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
					(4.0*nDotl*nDotv);
				vec3 outRadiance = PI* clight * nDotl * BRDF + ambientLight*cdiff*texture2D( aoMap, uVv * textureRepeat ).xyz;;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
			</script>

	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats;
		var raycaster, mouse;

		var loadingComplete = false; // true quando terminato caricamento del modello dell'isola grande

		var lightParameters = {
				red: 1.0,
				green: 1.0,
				blue: 1.0,
				intensity: 1.0,
		}

		var textureParameters = {
			normalScale: 1.0,
		}

		var normalMap = loadTexture( "textures/cushion_normals.jpg" );

		var uniforms = {
				cspec:	{ type: "v3", value: new THREE.Vector3(0.01,0.01,0.01) },
				cdiff:	{ type: "v3", value: new THREE.Vector3(0.5,0,0.5) },
				roughness: {type: "f", value: 0.7},
				normalMap:	{ type: "t", value: normalMap},
				normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				clight:	{ type: "v3", value: new THREE.Vector3() }
		};


		vs = document.getElementById("vertex").textContent;
		fs = document.getElementById("fragment").textContent;

		ourMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
		uniforms.pointLightPosition.value = new THREE.Vector3(20, 20, 20);


		function loadTexture(file) {
			var texture = new THREE.TextureLoader().load(file , function ( texture ) {
				texture.minFilter = THREE.LinearMipMapLinearFilter;
				texture.anisotropy = renderer.getMaxAnisotropy();
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.offset.set( 0, 0 );
				texture.needsUpdate = true;
				render();
				})
				return texture;
		}
		
		function Start() {

			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			renderer = new THREE.WebGLRenderer( { antialias: true, alpha:true } );

			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.setClearColor( "#1a053a", 0 ); // opacità 0 al caricamento, può essere cambiata interattivamente
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			//renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			camera.position.set( 0, 40, 250 );
			camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );



            ourMaterial.needsUpdate = true;

			





			// CARICAMENTO MODELLO
			var loader = new THREE.OBJLoader();

			loader.load(
				"models/cushion.obj",
				function(obj){

					obj.children.forEach(createNewGeometry);

					function createNewGeometry(children){
						var geometry = children.geometry;
						var cushion1 = new THREE.Mesh( geometry, ourMaterial );
						var cushion2 = new THREE.Mesh( geometry, ourMaterial );

						cushion1.scale.set(0.3, 0.3, 0.3);
						cushion1.rotation.z = 110 * Math.PI/180;
						cushion1.rotation.y = -60 * Math.PI/180;
						cushion1.position.x = -150;

						cushion2.scale.set(0.3, 0.3, 0.3);
						cushion2.rotation.z = -110 * Math.PI/180;
						cushion2.rotation.y = 40 * Math.PI/180;
						cushion2.position.x = 100;

						scene.add( cushion1 );
						scene.add( cushion2 );
						//objects.push(mesh);}
						loadingComplete = true;
					}
				}
			);


		



			/*var loader = new THREE.OBJLoader();
			loader.load(
				// path del modello
				"models/cushion.obj",

				// onLoad callback
				function ( obj ) {
					lamp = obj;
		
                    lamp.position.y = 60;
					lamp.rotation.x = -90 * Math.PI/180;

					lamp.castShadow = true;
					lamp.receiveShadow = true;

					scene.add( obj );
					loadingComplete = true;
				},

				// onProgress callback
				function ( xhr ) {
					console.log("Island 3D model " + (xhr.loaded / xhr.total * 100) + '% loaded');
				},

				// onError callback
				function ( err ) {
					console.error('An error happened');
				}
			);*/
			


            // prova sfera
            /*var uniforms = {
                "materialColor": { type: "v3", value: new THREE.Vector3() }
            };

            var vs = document.getElementById("vertex").textContent;
            var fs = document.getElementById("fragment").textContent;

            uniforms.materialColor.value = new THREE.Vector3(1.0,0.0,0.0);

            var sphereMaterial = new THREE.ShaderMaterial({ 
                uniforms: uniforms,
                vertexShader: vs,
                fragmentShader: fs
            });

            sphere = new THREE.Mesh( new THREE.SphereGeometry( 10, 32, 16 ), sphereMaterial );

            scene.add( sphere );*/




			// LUCI
			/*hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.4);
			hemiLight.position.set(0, 0, 2);
			scene.add(hemiLight);*/

			/*dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
			dirLight.position.set(1, 8, 6);
			dirLight.position.multiplyScalar(50);
			scene.add(dirLight);
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;*/
			

			

			// STATS
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);
		
			
			// ORBIT CONTROLS
			controls = new THREE.OrbitControls(camera);
			controls.addEventListener('change', Render);


			
			
		}
		


		// CALCOLO POSIZIONE MOUSE
		function onMouseMove(event) {
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
		}


		
		function Update() {

			requestAnimationFrame(Update);

			if(loadingComplete){ // se il caricamento del modello dell'isola grande è terminato

				
				
				}
				
			stats.update();
			Render();

			
			
		}
		


		function Render() {
			updateUniforms();
			renderer.render(scene, camera);

		}
		
		function updateUniforms() {

			uniforms.clight.value = new THREE.Vector3(
				lightParameters.red * lightParameters.intensity,
				lightParameters.green * lightParameters.intensity,
				lightParameters.blue * lightParameters.intensity);
			uniforms.normalScale.value = new THREE.Vector2( textureParameters.normalScale, textureParameters.normalScale );

		}

		Start();
		Update();
			

		</script>
		<div id="text">
			<p>
				Far, far away there's an unknown place <br /> where time can be controlled . . .
			</p>
		</div>
	</body>
</html>