<html>
	<head>
		<title>2nd Project - Vulcano</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}

		/*#text{
			width: 40%;
			position: absolute;
			left: 30%;
			top: 10%;
			text-align: center;
		}

		#text p{
			color: #e3e3e3;
			font-family: 'Antic', sans-serif;
		}*/
	
		</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OBJLoader.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<!--<link href="https://fonts.googleapis.com/css?family=Antic&display=swap" rel="stylesheet">-->

        <script type="text/x-glsl" id="vertex">
        varying vec3 vNormal;
        varying vec3 vPosition;

        void main() {
            vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
            vPosition = vPos.xyz;
            vNormal = normalMatrix * normal;
            gl_Position = projectionMatrix * vPos;
        }
        </script>

        <script type="text/x-glsl" id="fragment">
		varying vec3 vNormal;
		varying vec3 vPosition;
		uniform vec3 pointLightPosition; // in world space
		uniform vec3 clight;
		uniform vec3 cdiff;
		const float PI = 3.14159;

		void main() {
			vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
			vec3 l = normalize(lPosition.xyz - vPosition.xyz);
			vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
			float nDotl = max(dot( n, l ),0.0);

			// formula would be:
			// outRadiance = clight * PI * cdiff/PI * nDotl, the two PI cancel out

			vec3 outRadiance = clight * nDotl * cdiff;

			// gamma encode the final value

			gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			//gl_FragColor = vec4(vNormal, 1.0);
		}
        </script>

	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats;
		var lamp, pivot1, pivot2;
		var raycaster, mouse;
		var night, day;

		var loadingComplete = false; // true quando terminato caricamento del modello dell'isola grande

		var lightParameters = {
				red: 1.0,
				green: 1.0,
				blue: 1.0,
				intensity: 1.5,
			}

		var cdiff = {
			red: 0.5,
			green: 0.0,
			blue: 0.5,
		}

		var uniforms = {
					cdiff:	{ type: "v3", value: new THREE.Vector3() },
					pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
					clight:	{ type: "v3", value: new THREE.Vector3() },
		};

		vs = document.getElementById("vertex").textContent;
		fs = document.getElementById("fragment").textContent;

		ourMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
		uniforms.pointLightPosition.value = new THREE.Vector3(20, 20, 20);

		
		function Start() {

			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			renderer = new THREE.WebGLRenderer( { antialias: true, alpha:true } );

			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.setClearColor( "#1a053a", 0 ); // opacità 0 al caricamento, può essere cambiata interattivamente
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			//renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			camera.position.set( 0, 40, 250 );
			camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );



            

			





			// CARICAMENTO MODELLO
			var loader = new THREE.OBJLoader();

			loader.load(
				"models/cushion.obj",
				function(obj){

					obj.children.forEach(createNewGeometry);

					function createNewGeometry(children){
						var geometry = children.geometry;
						var cushion1 = new THREE.Mesh( geometry, ourMaterial );
						var cushion2 = new THREE.Mesh( geometry, ourMaterial );

						cushion1.scale.set(0.3, 0.3, 0.3);
						cushion1.rotation.z = 110 * Math.PI/180;
						cushion1.rotation.y = -60 * Math.PI/180;
						cushion1.position.x = -150;

						cushion2.scale.set(0.3, 0.3, 0.3);
						cushion2.rotation.z = -110 * Math.PI/180;
						cushion2.rotation.y = 40 * Math.PI/180;
						cushion2.position.x = 100;

						scene.add( cushion1 );
						scene.add( cushion2 );
						//objects.push(mesh);}
						loadingComplete = true;
					}
				}
			);


		



			/*var loader = new THREE.OBJLoader();
			loader.load(
				// path del modello
				"models/cushion.obj",

				// onLoad callback
				function ( obj ) {
					lamp = obj;
		
                    lamp.position.y = 60;
					lamp.rotation.x = -90 * Math.PI/180;

					lamp.castShadow = true;
					lamp.receiveShadow = true;

					scene.add( obj );
					loadingComplete = true;
				},

				// onProgress callback
				function ( xhr ) {
					console.log("Island 3D model " + (xhr.loaded / xhr.total * 100) + '% loaded');
				},

				// onError callback
				function ( err ) {
					console.error('An error happened');
				}
			);*/
			


            // prova sfera
            /*var uniforms = {
                "materialColor": { type: "v3", value: new THREE.Vector3() }
            };

            var vs = document.getElementById("vertex").textContent;
            var fs = document.getElementById("fragment").textContent;

            uniforms.materialColor.value = new THREE.Vector3(1.0,0.0,0.0);

            var sphereMaterial = new THREE.ShaderMaterial({ 
                uniforms: uniforms,
                vertexShader: vs,
                fragmentShader: fs
            });

            sphere = new THREE.Mesh( new THREE.SphereGeometry( 10, 32, 16 ), sphereMaterial );

            scene.add( sphere );*/




			// LUCI
			/*hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.4);
			hemiLight.position.set(0, 0, 2);
			scene.add(hemiLight);*/

			/*dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
			dirLight.position.set(1, 8, 6);
			dirLight.position.multiplyScalar(50);
			scene.add(dirLight);
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;*/
			

			

			// STATS
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);
		
			
			// ORBIT CONTROLS
			controls = new THREE.OrbitControls(camera);
			controls.addEventListener('change', Render);


			
			
		}
		


		// CALCOLO POSIZIONE MOUSE
		function onMouseMove(event) {
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
		}


		
		function Update() {

			requestAnimationFrame(Update);

			if(loadingComplete){ // se il caricamento del modello dell'isola grande è terminato

				
				
				}
				
			stats.update();
			Render();

			
			
		}
		


		function Render() {
			updateUniforms();
			renderer.render(scene, camera);

		}
		
		function updateUniforms() {

			uniforms.cdiff.value = new THREE.Vector3(cdiff.red,cdiff.green,cdiff.blue);
			uniforms.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
			);
		}

		Start();
		Update();
			

		</script>
		<div id="text">
			<p>
				Far, far away there's an unknown place <br /> where time can be controlled . . .
			</p>
		</div>
	</body>
</html>